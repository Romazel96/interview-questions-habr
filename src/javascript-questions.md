# JavaScript

1. **Какие типы данных есть в javaScript?**

   - в JS есть примитивные типы данных и объекты. Примитивные: _Boolean, number, string, undefuned, null, BigInt, Symbol._ Объекты: _Object_

2. **Что такое переменные?**

   - Переменные - это "хранилище для данных". Переменная имеет выделенную область памяти и собственное имя.
   - Имена переменных могут содержать(**\$** и **\_** ). Переменные не могут начинаться с цифр и еще они регистрозависимые.

3. **В чем отличия var, let, const?**

   - Главное отличие var от let в их области видимости. Область видимости var - весь контекст выполнения, в котором он объявлен. Область видимости let ограничена фигурными скобками, в котором она объявлена.
   - Также если мы попытаеся обратиться к переменной до ее инициализации с var мы получим _undefined_, с let/const _ReferenceError_
   - Отличия let и const в том, что мы можем переинициализировать(мутировать) let, а const мы можем инициализировать только 1 раз.

4. **Что такое функция**

   - Функция - это разновидность _объекта_, которая используется для выполнения сложных алгоритмов поставленной задачи. Объявить функции можно двумя способами
     1. Function expression
     2. Function declaration

5. **В чем отличия Function expression и Function declaration**

1) _Методом объявления:_

```javascript
function test1() {
  console.log("Look me"); // Function declaration
}

const test2 = () => {
  console.log("Look me again!"); //Function expression
};
```

2. _Моментом создания._
   > Javascript объявляет и инициализирует Function declaration, до того, как начнется выполнение самой первой строчки кода - поэтому мы можем обратиться к Function declaration, до ее инициализации. Function expression создается в тот момент, когда выполнение кода дойдет до нее, если мы попробуем обратиться к ней до этого момента, то получим _ReferenceError_
3. _this_ **ДОПОЛНИТЬ**
4. _конструкторы_
   > Function Declaration может легко создавать конструкторы объектов, в то время как стрелочная функция не может создавать конструкторы.
5. _Неявные возврат_

   > Function Declaration использует оператор возврата, в противном случае он вернет undefined. В стрелочной функции можно вернуть значение, если в функции содержится только 1 выражение и фигурные скобки отсуствуют

6. **что такое hoisting (всплытие/поднятие)?**

   - это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен.
   - _Объявление переменной всегда обрабатывается до выполнения кода_
   - _Объявленные переменные, независимо от контекста выполнения, являются ненастраиваемыми свойствами. Необъявленные переменные это настраиваемые свойства (т.е. их можно удалять)._ -_Объявление переменных (как и любые другие объявления) обрабатываются до выполнения кода. Где бы не находилось объявление, это равнозначно тому, что переменную объявили в самом начале кода. Это значит, что переменная становится доступной до того, как она объявлена. Такое поведение называется "поднятием" (в некоторых источниках "всплытием")._

     ```javascript
     bla = 2;
     var bla;
     // ...
     // читается как:
     var bla;
     bla = 2;
     ```

   - _Важно отметить, что подъем будет влиять на объявление переменной, но не на инициализацию ее значения. Значение присваивается при выполнении оператора присваивания:_

   - _все необъявленные переменные это по факту глобальные переменные._

     ```javascript
     function hoist() {
       a = 20;
       var b = 100;
     }

     hoist();

     console.log(a);
     // Доступ как к глобальной переменной вне функции hoist()
     //Выводит: 20
     console.log(b);
     /* Как только b была назначена, она заключена в рамки области видимости функции hoist(). Что означает то, что мы не можем вывести её за рамки функции.
     Вывод: ReferenceError: b is not defined */
     ```

7. **Что такое THIS**
8. **Зачем нужны функции call и apply?**
9. **что такое замыкание?**

- возможность ссылаться на конкретный экземпляр локальной привязки в пределах замкнутой области видимости. Функция, которая ссылается на привязки из окружающих ее локальных областей видимости, называется замыканием

  ```javascript
  function outerFunction() {
    const outer = `I see the outer variable!`;
    function innerFunction() {
      console.log(outer);
    }
    return innerFunction;
  }
  outerFunction()(); // I see the outer variable!
  ```

10. **что такое рекурсия?**

- Рекурсия - это один из приемов в программировании, когда функция вызывает саму себя. В рекурсии должны присутствовать:

  1. базис рекурсии - это условие, при котором рекурсия завершает свое выполнение
  2. шаг рекурсии - это действие, которое будет выполняться до тех пор, пока не достигнет базиса рекурсии.

11. **что добавили в ES, чем вы пользуетесь из добавленного?**

- стрелочные функции
- Деструктурирующее присваивание
- шаблонные литералы(обратные кавычки), в которых мы можем использовать выражения. (`${выражение}`)
- let, const
- добавлены promise
- оператор возведения в степень \*\*
- метод _Array.prototype.includes_, который проверяет, содержится ли переданный аргумент в массиве.
- асинхронность теперь официально поддерживается (async/await);
- «висячие» запятые в параметрах функций. Добавлена возможность ставить запятые в конце списка аргументов функций;
- добавлено два новых метода для работы со строками: padStart() и padEnd(). Метод padStart() подставляет дополнительные символы слева, перед началом строки. А padEnd(), в свою очередь, справа, после конца строки;

```javascript
var a, b, rest;
[a, b] = [1, 2];
console.log(a); // 1
console.log(b); // 2

[a, b, ...rest] = [1, 2, 3, 4, 5];
console.log(a); // 1
console.log(b); // 2
console.log(rest); // [3, 4, 5]

({ a, b } = { a: 1, b: 2 });
console.log(a); // 1
console.log(b); // 2

({ a, b, ...rest } = { a: 1, b: 2, c: 3, d: 4 });
// ES2016 - ещё не реализовано Firefox 47a01
```

12. **Что такое ошибка undefined**

- это значит, что мы не присвоили значение переменной

13. **Что такое глобальные переменные, какие проблемы могут быть с ними связаны?**

- Глобальные переменные - переменные, которые объявлены внекакого-либо блока, и их область видимости весь скрипт. Из-за этого могут возникуть проблемы с инициализацией и перезаписью переменных

14. **В чем отличия === и ==?**
    Строгое сравнение(===) проверяет равенство без приведения типов. Например если сравнить “ “ и false, то результат строгого неравенства будет false,а если сравнивать не строгим, то true
15. **Что такое null?**
    - null - это тип примитив, который представляет отсутствие какого-либо объектного значения. null часто присутствует в местах где ожидается объект, но подходящего объекта нет.
16. **Что такое методы?**

    - Метод - это встроенная функция, которая есть у каждого типа данных(Кроме null, undefined), доступных через точку. Метод упрощает работу с данными

17. **что такое свойства функций?**

    - Функции содержат полезные свойства, которые можно использовать. Например мы можем узнать имя функции с помощью .name, или количество параметров с помощью length. Также пользователь может помещать в функции свои свойства, к которым можно обратиться. Переменная это не свойство

18. **Что такое анонимные функции?**

    - Анонимная функция - это функция, который была объявлена без собственного имени

19. **какие есть методы у массивов**

    - forEach() - выполняет указанную функцию один раз для каждого элемента в массиве
    - reduce() - применяет функцию к каждому элементу массива, возвращая одна результирующее свойство.
    - map() - создает новый массив с результатом вызова функции для каждого элемента массива
    - split() - разбивает объект String на массив строк путём разделения строки указанной подстрокой.
    - splice() - изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.
    - join() - объединяет все элементы массива (или массивоподобного объекта) в строку.
    - concat() - возвращает новый массив, состоящий из массива, на котором он был вызван, соединённого с другими массивами и/или значениями, переданными в качестве аргументов.
    - filter() - выполняет указанную функцию для каждого элемента в массиве, и возвращает новый массив с элементами, которые прошли проверку
    - reverse() - изменяет порядок элементов в массиве на обратный
    - sort() - сортирует на месте массив и возвращает его. Порядок cортировки по умолчанию соответствует порядку кодовых точек Unicode.

20. **Что такое Объект?**

- Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
  . Объект используется для хранения коллекций различных значений. Свойства объекта - это пара ключ-значение. Объект можно создать двумя способами:

```javascript
let user = new Object(); // синтаксис "конструктор объекта"
let user = {}; // синтаксис "литерал объекта"
```

- Объект можно изменить, если он объявлен через константу. _const защищает от изменений только саму переменную, но не ее содержимое_
- Чтобы получить доступ к значение объекта, мы можем обратиться к значению через точку или через квадратные скобки. Квадратные скобки позволяют взять ключ из переменной
  > Все объекты в JavaScript являются потомками Object; все объекты наследуют методы и свойства из прототипа объекта Object.prototype, хотя они и могут быть переопределены. Например, прототипы других конструкторов переопределяют свойство constructor и предоставляют свои собственные методы toString(). Изменения в объекте прототипа Object распространяются на все объекты до тех пор, пока свойства и методы, учитывающие эти изменения, не переопределяются дальше по цепочке прототипов.

19. **Отличия объектов от примитивных типов данных**

- Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке».

```javascript
let user = { name: "Иван" };

let admin = user;

admin.name = "Петя"; // изменено по ссылке из переменной "admin"

alert(user.name); // 'Петя', изменения видны по ссылке из переменной "user"
```

```javascript
let a = {};
let b = a; // копирование по ссылке

alert(a == b); // true, т.к. обе переменные ссылаются на один и тот же объект
alert(a === b); // true
```

```javascript
let a = {};
let b = {}; // два независимых объекта

alert(a == b); // false
```

20. **Какие методы есть у Объектов**

- _Object.assign(dest, [src1, src2, src3...])_ - копирует свойства всех исходных объектов в целевой объект. Важно! этот метод не делает глубокое клонирование объекта.

  ```javascript
  let user = { name: "Иван" };

  let permissions1 = { canView: true };
  let permissions2 = { canEdit: true };

  // копируем все свойства из permissions1 и permissions2 в user
  Object.assign(user, permissions1, permissions2);

  // теперь user = { name: "Иван", canView: true, canEdit: true }
  ```

- _Object.keys(obj)_ - Возвращает массив, содержащий имена всех собственных перечислимых свойств переданного объекта.
- _Object.create(proto[, propertiesObject])_ - создаёт и возвращает новый объект с указанным прототипом и свойствами.

  ```javascript
  const obj = {
    sega: 19,
    adi: 18,
  };
  const newObj = Object.create(obj);
  console.log(newObj);
  ```

- _Object.freeze()_ - замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту, удаление старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и записываемости. В сущности, объект становится эффективно неизменным. Метод возвращает замороженный объект.
- _Object.is(value1, value2)_ - определяет, являются ли два значения одинаковыми значениями.

  ```javascript
  Object.is("foo", "foo"); // true
  Object.is(window, window); // true

  Object.is("foo", "bar"); // false
  Object.is([], []); // false

  var test = { a: 1 };
  Object.is(test, test); // true

  Object.is(null, null); // true

  // Специальные случаи
  Object.is(0, -0); // false
  Object.is(-0, -0); // true
  Object.is(NaN, 0 / 0); // true
  ```

- _Object.defineProperty(obj, prop, descriptor)_ - определяет новое или изменяет существующее свойство непосредственно на объекте, возвращая этот объект.
- _Object.getOwnPropertyDescriptor()_
- _Object.getOwnPropertyNames()_
- _Object.getOwnPropertySymbols()_

- _Object.getPrototypeOf()_
- _Object.isExtensible()_
- _Object.isFrozen()_ - определяет, был ли объект заморожен.
- _Object.isSealed()_
- _Object.observe()_ - используется для асинхронного обзора изменений в объекте. Он предоставляет поток изменений в порядке их возникновения.
- _Object.preventExtensions()_
- _Object.seal()_ - запечатывает объект, предотвращая добавление новых свойств к объекту и делая все существующие свойства не настраиваемыми. Значения представленных свойств всё ещё могут изменяться, поскольку они остаются записываемыми.
- _Object.setPrototypeOf()_

21. **Что такое ООП?**

    - Объектно ориентированное программирование - это парадигма разработки программных систем, в которой приложения состоят из объектов.

22. **4 Парадигмы ООП, и что они значат**

    - Инкапсуляция - защищает данные и код от внешнего вмешательства. Благодаря этому отсуствует риск, когда одна функция может взаимодействовать на другую без нашего ведома.
    - Наследование - с помощью наследования один объект может приобретать свойства другого
    - Полиморфизм - Возможность дополнять объект функционалом. Возможность выступать объекту в разных формах. Классический полиморфизм — замещение, переопределение методов.
    - Абстракция — в ООП это придание объекту характеристик, которые четко выделяет его на фоне остальных, определяя его концептуальные границы.

23. **Чем опасен цикл for in?**

    - цикл for in опасен тем, что он пробегает не только по ключам и свойстам объекта, но и заходит в его прототип, это может привести к проблемамч
      что такое promise

что такое строгий режим? (strict mode)

24. **Что такое делегирование событий?**

25. **Как работает делегирование событий?**

26. **Как работает прототипное наследование**

27. **В чем отличие forEach от map?**

28. **В чем разница между переменной , которая является: null, undefined или является необъявленной?**

29. **Каков типичный вариант использования анонимных функций?**

30. **В чем разница между объектами хоста и собственными объектами?**

31. **Объясните разницу между: function Person(){}, var person = Person()и var person = new Person()?**

32. **В чем разница между ==и ===?**

33. **Что такое тернарный оператор, почему он так называется**

34. **Какие инструменты и методы вы используете для отладки кода JavaScript?**

35. **Объясните разницу между синхронными и асинхронными функциями.**

36. **что такое функции высшего порядка?**

37. **что такое деструктаризация?**

38. **что такое promise? где и как его использовать**

39. **что происходит со старым значением в переменной, после того как мы ее переопределили?**

    - при переопределении переменной, старое значение удаляется

40. **как называются языки программирования, в которых мы можем не связывать типы данных с переменной?**

    - язык программирование в котором мы можем не связывать тип данных с переменной называется _динамически типизированным_

41. **Как будет вести себя результат вычисления, если где-то в выражении будет NaN?**

    - если где-то в расчете будет NaN, то результатом вычислений с его участием будет NaN.

42. **Как работает оператор запятая?**

- оператор запятая (,) - предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. Каждое выражение выполняется, но возвращается результат только последнего. оператор запятая имеет низкий приоритет, следовательно нужно использовать скобки

43. **чему равно сравнение null == undefined? что можете рассказать об этом сравнении?**

- для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому null == 0 ложно.

44. **Как сравниваются строки?**

- Строки сравниваются посимвольно в лексикографическом порядке

45. **Какие логические операторы есть в js? как они работают?**

- в js, есть 3 логических оператора - || (или), && (и), ! (не)
- оператор || - запинается на правде (result = a || b;), если все операторы ложные, то возвращается последний из них
- оператор && - запинается на лжи ()

46. **что такое "use strict"**

- use strict - это строгий режим в js

47. ***

48. ***

49. ***

50. ***
