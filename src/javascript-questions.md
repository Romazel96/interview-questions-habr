# JavaScript

1. **Какие типы данных есть в javaScript?**

   - в JS есть примитивные типы данных и объекты. Примитивные: _Boolean, number, string, undefuned, null, BigInt, Symbol._ Объекты: _Object_

2. **Что такое переменные?**

   - Переменные - это "хранилище для данных". Переменная имеет выделенную область памяти и собственное имя.
   - Имена переменных могут содержать(**\$** и **\_** ). Переменные не могут начинаться с цифр и еще они регистрозависимые.

3. **В чем отличия var, let, const?**

   - Главное отличие var от let в их области видимости. Область видимости var - весь контекст выполнения, в котором он объявлен. Область видимости let ограничена фигурными скобками, в котором она объявлена.
   - Также если мы попытаеся обратиться к переменной до ее инициализации с var мы получим _undefined_, с let/const _ReferenceError_
   - Отличия let и const в том, что мы можем переинициализировать(мутировать) let, а const мы можем инициализировать только 1 раз.

4. **Что такое функция**

   - Функция - это разновидность _объекта_, которая используется для выполнения сложных алгоритмов поставленной задачи. Объявить функции можно двумя способами
     1. Function expression
     2. Function declaration

5. **В чем отличия Function expression и Function declaration**

   1. _Моментом создания._

- Javascript объявляет и инициализирует Function declaration, до того, как начнется выполнение самой первой строчки кода - поэтому мы можем обратиться к Function declaration, до ее инициализации. Function expression создается в тот момент, когда выполнение кода дойдет до нее, если мы попробуем обратиться к ней до этого момента, то получим _ReferenceError_

  2. _видимость в строгом режиме_

  - В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.

  ```js
  let age = prompt("Сколько Вам лет?", 18);

  // в зависимости от условия объявляем функцию
  if (age < 18) {
    function welcome() {
      alert("Привет!");
    }
  } else {
    function welcome() {
      alert("Здравствуйте!");
    }
  }

  // ...не работает
  welcome(); // Error: welcome is not defined
  ```

  3. _Методом объявления_

  ```javascript
  function test1() {
    console.log("Look me"); // Function declaration
  }

  const test2 = () => {
    console.log("Look me again!"); //Function expression
  };
  ```

8. **что такое hoisting (всплытие/поднятие)?**

   - это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен.
   - _Объявление переменной всегда обрабатывается до выполнения кода_
   - _Объявленные переменные, независимо от контекста выполнения, являются ненастраиваемыми свойствами. Необъявленные переменные это настраиваемые свойства (т.е. их можно удалять)._ -_Объявление переменных (как и любые другие объявления) обрабатываются до выполнения кода. Где бы не находилось объявление, это равнозначно тому, что переменную объявили в самом начале кода. Это значит, что переменная становится доступной до того, как она объявлена. Такое поведение называется "поднятием" (в некоторых источниках "всплытием")._

     ```javascript
     bla = 2;
     var bla;
     // ...
     // читается как:
     var bla;
     bla = 2;
     ```

   - _Важно отметить, что подъем будет влиять на объявление переменной, но не на инициализацию ее значения. Значение присваивается при выполнении оператора присваивания:_

   - _все необъявленные переменные это по факту глобальные переменные._

     ```javascript
     function hoist() {
       a = 20;
       var b = 100;
     }

     hoist();

     console.log(a);
     // Доступ как к глобальной переменной вне функции hoist()
     //Выводит: 20
     console.log(b);
     /* Как только b была назначена, она заключена в рамки области видимости функции hoist(). Что означает то, что мы не можем вывести её за рамки функции.
     Вывод: ReferenceError: b is not defined */
     ```

9. **Что такое THIS**
10. **Зачем нужны функции call и apply?**
11. **что такое замыкание?**

- возможность ссылаться на конкретный экземпляр локальной привязки в пределах замкнутой области видимости. Функция, которая ссылается на привязки из окружающих ее локальных областей видимости, называется замыканием

  ```javascript
  function outerFunction() {
    const outer = `I see the outer variable!`;
    function innerFunction() {
      console.log(outer);
    }
    return innerFunction;
  }
  outerFunction()(); // I see the outer variable!
  ```

10. **что такое рекурсия?**

- Рекурсия - это один из приемов в программировании, когда функция вызывает саму себя. В рекурсии должны присутствовать:

  1. базис рекурсии - это условие, при котором рекурсия завершает свое выполнение
  2. шаг рекурсии - это действие, которое будет выполняться до тех пор, пока не достигнет базиса рекурсии.

11. **что добавили в ES, чем вы пользуетесь из добавленного?**

- стрелочные функции
- Деструктурирующее присваивание
- шаблонные литералы(обратные кавычки), в которых мы можем использовать выражения. (`${выражение}`)
- let, const
- добавлены promise
- оператор возведения в степень \*\*
- метод _Array.prototype.includes_, который проверяет, содержится ли переданный аргумент в массиве.
- асинхронность теперь официально поддерживается (async/await);
- «висячие» запятые в параметрах функций. Добавлена возможность ставить запятые в конце списка аргументов функций;
- добавлено два новых метода для работы со строками: padStart() и padEnd(). Метод padStart() подставляет дополнительные символы слева, перед началом строки. А padEnd(), в свою очередь, справа, после конца строки;

```javascript
var a, b, rest;
[a, b] = [1, 2];
console.log(a); // 1
console.log(b); // 2

[a, b, ...rest] = [1, 2, 3, 4, 5];
console.log(a); // 1
console.log(b); // 2
console.log(rest); // [3, 4, 5]

({ a, b } = { a: 1, b: 2 });
console.log(a); // 1
console.log(b); // 2

({ a, b, ...rest } = { a: 1, b: 2, c: 3, d: 4 });
// ES2016 - ещё не реализовано Firefox 47a01
```

12. **Что такое ошибка undefined**

- это значит, что мы не присвоили значение переменной

13. **Что такое глобальные переменные, какие проблемы могут быть с ними связаны?**

- Глобальные переменные - переменные, которые объявлены внекакого-либо блока, и их область видимости весь скрипт. Из-за этого могут возникуть проблемы с инициализацией и перезаписью переменных

14. **В чем отличия === и ==?**
    Строгое сравнение(===) проверяет равенство без приведения типов. Например если сравнить “ “ и false, то результат строгого неравенства будет false,а если сравнивать не строгим, то true
15. **Что такое null?**
    - null - это тип примитив, который представляет отсутствие какого-либо объектного значения. null часто присутствует в местах где ожидается объект, но подходящего объекта нет.
16. **Что такое методы?**

    - Метод - это встроенная функция, которая есть у каждого типа данных(Кроме null, undefined), доступных через точку. Метод упрощает работу с данными

17. **что такое свойства функций?**

    - Функции содержат полезные свойства, которые можно использовать. Например мы можем узнать имя функции с помощью .name, или количество параметров с помощью length. Также пользователь может помещать в функции свои свойства, к которым можно обратиться. Переменная это не свойство

18. **Что такое анонимные функции?**

    - Анонимная функция - это функция, который была объявлена без собственного имени

19. **какие есть методы у массивов**

    - forEach() - выполняет указанную функцию один раз для каждого элемента в массиве
    - reduce() - применяет функцию к каждому элементу массива, возвращая одна результирующее свойство.
    - map() - создает новый массив с результатом вызова функции для каждого элемента массива
    - split() - разбивает объект String на массив строк путём разделения строки указанной подстрокой.
    - splice() - изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.
    - join() - объединяет все элементы массива (или массивоподобного объекта) в строку.
    - concat() - возвращает новый массив, состоящий из массива, на котором он был вызван, соединённого с другими массивами и/или значениями, переданными в качестве аргументов.
    - filter() - выполняет указанную функцию для каждого элемента в массиве, и возвращает новый массив с элементами, которые прошли проверку
    - reverse() - изменяет порядок элементов в массиве на обратный
    - sort() - сортирует на месте массив и возвращает его. Порядок cортировки по умолчанию соответствует порядку кодовых точек Unicode.

20. **Что такое Объект?**

- Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
  . Объект используется для хранения коллекций различных значений. Свойства объекта - это пара ключ-значение. Объект можно создать двумя способами:

```javascript
let user = new Object(); // синтаксис "конструктор объекта"
let user = {}; // синтаксис "литерал объекта"
```

- Объект можно изменить, если он объявлен через константу. _const защищает от изменений только саму переменную, но не ее содержимое_
- Чтобы получить доступ к значение объекта, мы можем обратиться к значению через точку или через квадратные скобки. Квадратные скобки позволяют взять ключ из переменной
  > Все объекты в JavaScript являются потомками Object; все объекты наследуют методы и свойства из прототипа объекта Object.prototype, хотя они и могут быть переопределены. Например, прототипы других конструкторов переопределяют свойство constructor и предоставляют свои собственные методы toString(). Изменения в объекте прототипа Object распространяются на все объекты до тех пор, пока свойства и методы, учитывающие эти изменения, не переопределяются дальше по цепочке прототипов.

19. **Отличия объектов от примитивных типов данных**

- Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке».

```javascript
let user = { name: "Иван" };

let admin = user;

admin.name = "Петя"; // изменено по ссылке из переменной "admin"

alert(user.name); // 'Петя', изменения видны по ссылке из переменной "user"
```

```javascript
let a = {};
let b = a; // копирование по ссылке

alert(a == b); // true, т.к. обе переменные ссылаются на один и тот же объект
alert(a === b); // true
```

```javascript
let a = {};
let b = {}; // два независимых объекта

alert(a == b); // false
```

20. **Какие методы есть у Объектов**

- _Object.assign(dest, [src1, src2, src3...])_ - копирует свойства всех исходных объектов в целевой объект. Важно! этот метод не делает глубокое клонирование объекта.

  ```javascript
  let user = { name: "Иван" };

  let permissions1 = { canView: true };
  let permissions2 = { canEdit: true };

  // копируем все свойства из permissions1 и permissions2 в user
  Object.assign(user, permissions1, permissions2);

  // теперь user = { name: "Иван", canView: true, canEdit: true }
  ```

- _Object.keys(obj)_ - Возвращает массив, содержащий имена всех собственных перечислимых свойств переданного объекта.
- _Object.create(proto[, propertiesObject])_ - создаёт и возвращает новый объект с указанным прототипом и свойствами.

  ```javascript
  const obj = {
    sega: 19,
    adi: 18,
  };
  const newObj = Object.create(obj);
  console.log(newObj);
  ```

- _Object.freeze()_ - замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту, удаление старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и записываемости. В сущности, объект становится эффективно неизменным. Метод возвращает замороженный объект.
- _Object.is(value1, value2)_ - определяет, являются ли два значения одинаковыми значениями.

  ```javascript
  Object.is("foo", "foo"); // true
  Object.is(window, window); // true

  Object.is("foo", "bar"); // false
  Object.is([], []); // false

  var test = { a: 1 };
  Object.is(test, test); // true

  Object.is(null, null); // true

  // Специальные случаи
  Object.is(0, -0); // false
  Object.is(-0, -0); // true
  Object.is(NaN, 0 / 0); // true
  ```

- _Object.defineProperty(obj, prop, descriptor)_ - определяет новое или изменяет существующее свойство непосредственно на объекте, возвращая этот объект.
- _Object.getOwnPropertyDescriptor()_
- _Object.getOwnPropertyNames()_
- _Object.getOwnPropertySymbols()_

- _Object.getPrototypeOf()_
- _Object.isExtensible()_
- _Object.isFrozen()_ - определяет, был ли объект заморожен.
- _Object.isSealed()_
- _Object.observe()_ - используется для асинхронного обзора изменений в объекте. Он предоставляет поток изменений в порядке их возникновения.
- _Object.preventExtensions()_
- _Object.seal()_ - запечатывает объект, предотвращая добавление новых свойств к объекту и делая все существующие свойства не настраиваемыми. Значения представленных свойств всё ещё могут изменяться, поскольку они остаются записываемыми.
- _Object.setPrototypeOf()_

21. **Что такое ООП?**

    - Объектно ориентированное программирование - это парадигма разработки программных систем, в которой приложения состоят из объектов.

22. **4 Парадигмы ООП, и что они значат**

    - Инкапсуляция - защищает данные и код от внешнего вмешательства. Благодаря этому отсуствует риск, когда одна функция может взаимодействовать на другую без нашего ведома.
    - Наследование - с помощью наследования один объект может приобретать свойства другого
    - Полиморфизм - Возможность дополнять объект функционалом. Возможность выступать объекту в разных формах. Классический полиморфизм — замещение, переопределение методов.
    - Абстракция — в ООП это придание объекту характеристик, которые четко выделяет его на фоне остальных, определяя его концептуальные границы.

23. **Чем опасен цикл for in?**

    - цикл for in опасен тем, что он пробегает не только по ключам и свойстам объекта, но и заходит в его прототип, это может привести к проблемамч
      что такое promise

что такое строгий режим? (strict mode)

24. **Что такое делегирование событий?**

25. **Как работает делегирование событий?**

26. **Как работает прототипное наследование**

27. **В чем отличие forEach от map?**

28. **В чем разница между переменной , которая является: null, undefined или является необъявленной?**

29. **Каков типичный вариант использования анонимных функций?**

30. **В чем разница между объектами хоста и собственными объектами?**

31. **Объясните разницу между: function Person(){}, var person = Person()и var person = new Person()?**

32. **В чем разница между ==и ===?**

33. **Что такое тернарный оператор, почему он так называется**

34. **Какие инструменты и методы вы используете для отладки кода JavaScript?**

35. **Объясните разницу между синхронными и асинхронными функциями.**

36. **что такое функции высшего порядка?**

37. **что такое деструктаризация?**

38. **что такое promise? где и как его использовать**

39. **что происходит со старым значением в переменной, после того как мы ее переопределили?**

    - при переопределении переменной, старое значение удаляется

40. **как называются языки программирования, в которых мы можем не связывать типы данных с переменной?**

    - язык программирование в котором мы можем не связывать тип данных с переменной называется _динамически типизированным_

41. **Как будет вести себя результат вычисления, если где-то в выражении будет NaN?**

    - если где-то в расчете будет NaN, то результатом вычислений с его участием будет NaN.

42. **Как работает оператор запятая?**

    - оператор запятая (,) - предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. Каждое выражение выполняется, но возвращается результат только последнего. оператор запятая имеет низкий приоритет, следовательно нужно использовать скобки

43. **чему равно сравнение null == undefined? что можете рассказать об этом сравнении?**

    - для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому null == 0 ложно.

44. **Как сравниваются строки?**

    - Строки сравниваются посимвольно в лексикографическом порядке

45. **Какие логические операторы есть в js? как они работают?**

    - в js, есть 3 логических оператора - || (или), && (и), ! (не)
    - оператор || - запинается на правде (result = a || b;), если все операторы ложные, то возвращается последний из них
    - оператор && - запинается на лжи ()

46. **что такое "use strict"**

    - use strict - это строгий режим в js

47. **Что вы можете рассказать про оператор "??"**

    - Оператор "??" был добавлен совсем недавно - из двух аргументов он возвращает, тот у которого значение определено (null/undefined он отсеивает). У него низкий приоритет,
      поэтому для его использования скорее всего потребуются скобки. Также этот оператор нельзя использовать с операторами _||, &&_, но можно обойти это ограничение с помощью
      скобок.

48. **как называется повторение шага в цикле?**

    - итерация

49. **Как можно завершить цикл, или перейти к следующей итерации цикла?**

    - для завершения цикла используется break, для того, чтобы перейти к следующей итерации используется continue

    ```js
    for (let i = 0; i < 10; i++) {
      // если true, пропустить оставшуюся часть тела цикла
      if (i % 2 == 0) continue;

      alert(i); // 1, затем 3, 5, 7, 9
    }
    ```

    - нельзя использовать break/continue справа от оператора "?"

50. **Как можно выйти из нескольких уровней цикла?**

    - Для выхода из нескольких уровней цикла используются _метки_ - метка имеет вид идентификатора с двоеточием перед циклом.

    ```js
    outer: for (let i = 0; i < 3; i++) {

    for (let j = 0; j < 3; j++) {

        let input = prompt(Значение на координатах (${i},${j}), '');

        // если пустая строка или Отмена, то выйти из обоих циклов
        if (!input) break outer; // (*)

        // сделать что-нибудь со значениями...
    }
    }
    alert('Готово!');
    ```

    - Вызов break/continue возможен только внутри цикла, и метка должна находиться где-то выше этой директивы.
    - Обе этих директивы поддерживают метки, которые ставятся перед циклом. Метки – единственный способ для break/continue выйти за пределы текущего цикла, повлиять на выполнение внешнего.

51. **Что вы можете рассказать о конструкции switch case?**

    - Конструкция switch заменяет собой сразу несколько if.

```js
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
```

- Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее. Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch). Если ни один case не совпал – выполняется (если есть) вариант default
- Несколько вариантов case, использующих один код, можно группировать.

```js
switch (a) {
  case 4:
    alert("Правильно!");
    break;

  case 3: // (*) группируем оба case
  case 5:
    alert("Неправильно!");
    alert("Может вам посетить урок математики?");
    break;
  default:
    alert("Результат выглядит странновато. Честно.");
}
```

52. **Что происходит с внешней переменной, если в функции мы объявляем переменную с таким же именем**

    - Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю.

53. **Что такое параметр по умолчанию, как его задать?**

    - параметр по умолчанию - это значение параметра, используемое функцией, если значения параметра не было передано. Мы можем присвоить параметр по умолчания, когда объявляем параметры.

      ```js
      function(a, b = 0) {}
      ```

    - В данном случае _b = 0_ это число, но на его месте могло бы быть и более сложное выражение, которое бы вычислялось и присваивалось при отсутствии параметра. Например:

      ```js
      function showMessage(from, text = anotherFunction()) {
        // anotherFunction() выполнится только если не передан text
        // результатом будет значение text
      }
      ```

54. **Если параметр не указан, то его значение?**

    - undefined

55. **Что произойдет если использовать return без значения?**

    - Пустой return аналогичен return undefined. _Он приведет к немедленному выходу из функции!_

56. **Почему не следует добавлять перенос строки между return и его значением?**

    - потому что код не выполнится, _js подставит точку с запятой после return._ Но можно осуществить перенос с помощью скобки после _return_

57. **Какие префиксы вы используете?**

    - get..., check..., count... show...

58. **функция это значение?**

    - да, функция это значение, и мы можем работать с ней как со значением - копировать функцию в другую переменную и т.д

59. **Что такое callback функция?**

    - коллбэк функция(функция обратного вызова) - функция, которая передается как аргумент другой функции.

    ```js
    function ask(question, yes, no) {
      if (confirm(question)) yes();
      else no();
    }

    ask(
      "Вы согласны?",
      function () {
        alert("Вы согласились.");
      },
      function () {
        alert("Вы отменили выполнение.");
      }
    );
    ```

60. **Что такое стрелочные функции, в чем их отличия?**

    - у _стрелочных функций_ нет this. Если происходит обращение к this, его значение берётся снаружи. 2. _конструкторы_. Например, мы можем использовать это для итерации внутри метода объекта:

    ```js
    let group = {
      title: "Our Group",
      students: ["John", "Pete", "Alice"],

      showList() {
        this.students.forEach((student) => alert(this.title + ": " + student));
      },
    };

    group.showList();
    /*Если бы мы использовали «обычную» функцию, была бы ошибка: */
    ```

    - Отсутствие this естественным образом ведёт к другому ограничению: стрелочные функции не могут быть использованы как конструкторы. Они не могут быть вызваны с new.

    - У стрелочных функций также нет переменной arguments.

    - Function Declaration может легко создавать конструкторы объектов, в то время как _стрелочная функция не может создавать конструкторы_

    - Function Declaration использует оператор возврата, в противном случае он вернет undefined. _В стрелочной функции можно вернуть значение, если в функции содержится только 1 выражение и фигурные скобки отсуствуют_

61. **Что такое линтеры?**

62. **Что такое BDD - Behavior Driven Development?**

    - это методология тестирования и разработки ПО.
    - Как Тесты – они гарантируют, что функция работает правильно.
    - Как Документацию – заголовки блоков describe и it описывают поведение функции.
    - Как Примеры – тесты, по сути, являются готовыми примерами использования функции.
    - В BDD сначала пишут спецификацию, а потом реализацию. В конце у нас есть и то, и другое.

    - Спецификацию можно использовать тремя способами:

    ```js
    describe("Возводит x в степень n", function () {
      it("5 в степени 1 будет 5", function () {
        assert.equal(pow(5, 1), 5);
      });

      it("5 в степени 2 будет 25", function () {
        assert.equal(pow(5, 2), 25);
      });

      it("5 в степени 3 будет 125", function () {
        assert.equal(pow(5, 3), 125);
      });
    });
    ```

63. **Что такое транспилер и полифил?**

    - Частенько приходится поддерживать браузер, который не поддерживает всех функций js для этого есть инструмент, который преобразует ваш новый код в более старые эквиваленты кода. Этот процесс обычно называют “transpiling”
    - Слово polyfill - обозначает принятие определения новой функции и создания части кода , эквивалентного поведению, но способного работать в older JS environments(старой среде js).

64. **Какие методы вы используете для чистоты кода?**

    - Использование простых, но понятных имен для переменных или функций.
    - не использовать абстрактные названия - data, value...
    - использовать одинаковое форматирование кода (prettier)
    - не создавать функции, которые реализуют несколько действий
    - стараться писать код таким образом, чтобы он не требовал комментариев - код сам должен быть комментарием

65. **Что такое линты?**

    - ESLint - это инструмент статического анализа кода для выявления проблемных шаблонов, обнаруженных в коде JavaScript. Он приводит код к более-менее единому стилю, помогает избежать глупых ошибок, умеет автоматически исправлять многие из найденных проблем и отлично интегрируется со многими инструментами разработки

66.

67.

68.

69.

```

```
