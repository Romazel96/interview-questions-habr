# JavaScript

1. **Какие типы данных есть в javaScript?**

   - в JS есть примитивные типы данных и объекты. Примитивные: _Boolean, number, string, undefuned, null, BigInt, Symbol._ Объекты: _Object_

2. **Что такое переменные?**

   - Переменные - это "хранилище для данных". Переменная имеет выделенную область памяти и собственное имя.
   - Имена переменных могут содержать(**\$** и **\_** ). Переменные не могут начинаться с цифр и еще они регистрозависимые.

3. **В чем отличия var, let, const?**

   - Главное отличие var от let в их области видимости. Область видимости var - весь контекст выполнения, в котором он объявлен. Область видимости let ограничена фигурными скобками, в котором она объявлена.
   - Также если мы попытаеся обратиться к переменной до ее инициализации с var мы получим _undefined_, с let/const _ReferenceError_
   - Отличия let и const в том, что мы можем переинициализировать(мутировать) let, а const мы можем инициализировать только 1 раз.

4. **Что такое функция**

   - Функция - это разновидность _объекта_, которая используется для выполнения сложных алгоритмов поставленной задачи. Объявить функции можно двумя способами
     1. Function expression
     2. Function declaration

5. **В чем отличия Function expression и Function declaration**

   1. _Моментом создания._

   - Javascript объявляет и инициализирует Function declaration, до того, как начнется выполнение самой первой строчки кода - поэтому мы можем обратиться к Function declaration, до ее инициализации. Function expression создается в тот момент, когда выполнение кода дойдет до нее, если мы попробуем обратиться к ней до этого момента, то получим _ReferenceError_

   2. _видимость в строгом режиме_

   - В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.

   ```js
   let age = prompt("Сколько Вам лет?", 18);

   // в зависимости от условия объявляем функцию
   if (age < 18) {
     function welcome() {
       alert("Привет!");
     }
   } else {
     function welcome() {
       alert("Здравствуйте!");
     }
   }

   // ...не работает
   welcome(); // Error: welcome is not defined
   ```

   3. _Методом объявления_

   ```javascript
   function test1() {
     console.log("Look me"); // Function declaration
   }

   const test2 = () => {
     console.log("Look me again!"); //Function expression
   };
   ```

6. **что такое hoisting (всплытие/поднятие)?**

   - это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен.
   - _Объявление переменной всегда обрабатывается до выполнения кода_
   - _Объявленные переменные, независимо от контекста выполнения, являются ненастраиваемыми свойствами. Необъявленные переменные это настраиваемые свойства (т.е. их можно удалять)._ -_Объявление переменных (как и любые другие объявления) обрабатываются до выполнения кода. Где бы не находилось объявление, это равнозначно тому, что переменную объявили в самом начале кода. Это значит, что переменная становится доступной до того, как она объявлена. Такое поведение называется "поднятием" (в некоторых источниках "всплытием")._

     ```javascript
     bla = 2;
     var bla;
     // ...
     // читается как:
     var bla;
     bla = 2;
     ```

   - _Важно отметить, что подъем будет влиять на объявление переменной, но не на инициализацию ее значения. Значение присваивается при выполнении оператора присваивания:_

   - _все необъявленные переменные это по факту глобальные переменные._

     ```javascript
     function hoist() {
       a = 20;
       var b = 100;
     }

     hoist();

     console.log(a);
     // Доступ как к глобальной переменной вне функции hoist()
     //Выводит: 20
     console.log(b);
     /* Как только b была назначена, она заключена в рамки области видимости функции hoist(). Что означает то, что мы не можем вывести её за рамки функции.
     Вывод: ReferenceError: b is not defined */
     ```

7. **что такое замыкание?**

- возможность ссылаться на конкретный экземпляр локальной привязки в пределах замкнутой области видимости. Функция, которая ссылается на привязки из окружающих ее локальных областей видимости, называется замыканием

  ```javascript
  function outerFunction() {
    const outer = `I see the outer variable!`;
    function innerFunction() {
      console.log(outer);
    }
    return innerFunction;
  }
  outerFunction()(); // I see the outer variable!
  ```

10. **что такое рекурсия?**

- Рекурсия - это один из приемов в программировании, когда функция вызывает саму себя. В рекурсии должны присутствовать:

  1. базис рекурсии - это условие, при котором рекурсия завершает свое выполнение
  2. шаг рекурсии - это действие, которое будет выполняться до тех пор, пока не достигнет базиса рекурсии.

11. **что добавили в ES, чем вы пользуетесь из добавленного?**

- стрелочные функции
- Деструктурирующее присваивание
- шаблонные литералы(обратные кавычки), в которых мы можем использовать выражения. (`${выражение}`)
- let, const
- добавлены promise
- оператор возведения в степень \*\*
- метод _Array.prototype.includes_, который проверяет, содержится ли переданный аргумент в массиве.
- асинхронность теперь официально поддерживается (async/await);
- «висячие» запятые в параметрах функций. Добавлена возможность ставить запятые в конце списка аргументов функций;
- добавлено два новых метода для работы со строками: padStart() и padEnd(). Метод padStart() подставляет дополнительные символы слева, перед началом строки. А padEnd(), в свою очередь, справа, после конца строки;

```javascript
var a, b, rest;
[a, b] = [1, 2];
console.log(a); // 1
console.log(b); // 2

[a, b, ...rest] = [1, 2, 3, 4, 5];
console.log(a); // 1
console.log(b); // 2
console.log(rest); // [3, 4, 5]

({ a, b } = { a: 1, b: 2 });
console.log(a); // 1
console.log(b); // 2

({ a, b, ...rest } = { a: 1, b: 2, c: 3, d: 4 });
// ES2016 - ещё не реализовано Firefox 47a01
```

12. **Что такое ошибка undefined**

- это значит, что мы не присвоили значение переменной

13. **Что такое глобальные переменные, какие проблемы могут быть с ними связаны?**

- Глобальные переменные - переменные, которые объявлены внекакого-либо блока, и их область видимости весь скрипт. Из-за этого могут возникуть проблемы с инициализацией и перезаписью переменных

14. **В чем отличия === и ==?**

    Строгое сравнение(===) проверяет равенство без приведения типов. Например если сравнить “ “ и false, то результат строгого неравенства будет false,а если сравнивать не строгим, то true

15. **Что такое null?**

    - null - это тип примитив, который представляет отсутствие какого-либо объектного значения. null часто присутствует в местах где ожидается объект, но подходящего объекта нет.

16. **Что такое методы?**

    - Метод - это встроенная функция, которая есть у каждого типа данных(Кроме null, undefined), доступных через точку. Метод упрощает работу с данными

17. **что такое свойства функций?**

    - Функции содержат полезные свойства, которые можно использовать. Например мы можем узнать имя функции с помощью .name, или количество параметров с помощью length. Также пользователь может помещать в функции свои свойства, к которым можно обратиться. Переменная это не свойство

18. **Что такое анонимные функции?**

    - Анонимная функция - это функция, который была объявлена без собственного имени

19. **какие есть методы у массивов**

    - forEach() - выполняет указанную функцию один раз для каждого элемента в массиве
    - reduce() - применяет функцию к каждому элементу массива, возвращая одна результирующее свойство.
    - map() - создает новый массив с результатом вызова функции для каждого элемента массива
    - split() - разбивает объект String на массив строк путём разделения строки указанной подстрокой.
    - splice() - изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.
    - join() - объединяет все элементы массива (или массивоподобного объекта) в строку.
    - concat() - возвращает новый массив, состоящий из массива, на котором он был вызван, соединённого с другими массивами и/или значениями, переданными в качестве аргументов.
    - filter() - выполняет указанную функцию для каждого элемента в массиве, и возвращает новый массив с элементами, которые прошли проверку
    - reverse() - изменяет порядок элементов в массиве на обратный
    - sort() - сортирует на месте массив и возвращает его. Порядок cортировки по умолчанию соответствует порядку кодовых точек Unicode.

20. **Что такое Объект?**

    - _Объекты – это_ ассоциативные массивы с рядом дополнительных возможностей.
    - _Чтобы получить доступ к значение объекта_, мы можем обратиться к значению через точку или через квадратные скобки. Квадратные скобки позволяют взять ключ из переменной
    - _Все объекты в JavaScript являются потомками_ Object; все объекты наследуют методы и свойства из прототипа объекта Object.prototype, хотя они и могут быть переопределены. Например, прототипы других конструкторов переопределяют свойство constructor и предоставляют свои собственные методы toString(). Изменения в объекте прототипа Object распространяются на все объекты до тех пор, пока свойства и методы, учитывающие эти изменения, не переопределяются дальше по цепочке прототипов.
    - _Объект используется для хранения_ коллекций различных значений. Свойства объекта - это пара ключ-значение. Объект можно создать двумя способами:
    - _для удаления свойства объекта_ можем использовать оператор _delete_

    ```javascript
    let user = new Object(); // синтаксис "конструктор объекта"
    let user = {}; // синтаксис "литерал объекта"
    ```

21. **Можно ли изменить содержимое объекта, если объявление произошло через const?**

    - Объект можно изменить, если он объявлен через константу. _const защищает от изменений только саму переменную, но не ее содержимое_

22. **Можем ли мы получить свойство в объекте, которого не существует?**

    - Да. В отличии от других языков js может получить доступ к любому свойству. При обращении к свойству, которого нет, вернется undefined.

23. **Как мы можем проверить существование свойства в объекте?**

    - С помощь оператора _in_, мы можем проверить существует ли свойство.
    - Мы можем сравнить свойство с undefined, но это не всегда вернет верный результат(в том случае если свойства имеет значение undefined)

24. **Упорядочены ли свойства объектов?**

    - свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.

25. **Как js понимает, что нужно удалить объект? какие методы используются для этого?**

    - js постоянно анализирует, что находиться у него в памяти - js удаляет недостижимые объекты - сборка мусора
    - Сборка по поколениям (Generational collection) – объекты делятся на «новые» и «старые». Многие объекты появляются, выполняют свою задачу и быстро умирают, их можно удалять более агрессивно. Те, которые живут достаточно долго, становятся «старыми» и проверяются реже.
    - Инкрементальная сборка (Incremental collection) – если объектов много, то обход всех ссылок и пометка достижимых объектов может занять значительное время и привести к видимым задержкам выполнения скрипта. Поэтому интерпретатор пытается организовать сборку мусора поэтапно. Этапы выполняются по отдельности один за другим. Это требует дополнительного учёта для отслеживания изменений между этапами, но зато теперь у нас есть много крошечных задержек вместо одной большой.
    - Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.
    - сборка мусора происходит автоматически, мы не можем повлиять на нее

26. **Что такое конструктор объекта?**

    - обычный синтаксис литерала {...} позволяет создать только один объект. Но _зачастую нам нужно создать множество однотипных объектов_, таких как пользователи, элементы меню...
    - Это можно сделать при помощи _функции-коструктора_ и оператора _new_
    - Функции конструкторы являются обычными функциями, но есть 2 соглашние - Имя функции должно начинаться с большой буквы. Функция-коструктор должна вызываться при помощи оператора _new_
    - Обычно конструкторы ничего не возвращают явно. Их задача – записать все необходимое в this, который в итоге станет результатом.
    - Но если return всё же есть, то применяется простое правило: _При вызове return с объектом, будет возвращён объект, а не this._ _При вызове return с примитивным значением, примитивное значение будет отброшено._

27. **как мы можем проверить функция вызвана с помощью _new_, или нет?**

    - Мы можем проверить это с помощью свойства _new.target_ внутрии функции.
    - В случае, если функция вызвана при помощи new, то в new.target будет сама функция, в противном случае undefined.
    - Синтаксис опциональной цепочки ?. имеет три формы:
    - obj?.prop – возвращает obj.prop, если существует obj, и undefined в противном случае.
    - obj?.\[prop] – возвращает obj\[prop], если существует obj, и undefined в противном случае.
    - obj.method?.() – вызывает obj.method(), если существует obj.method, в противном случае возвращает undefined.

28. **Что такое опциональная цепочка "?" ?**

    - Опциональная цепочка ?. — это безопасный способ доступа к свойствам вложенных объектов, даже если какое-либо из промежуточных свойств не существует.
    - Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если часть перед ?. имеет значение undefined или null.

    ```js
    let user = {}; // пользователь без адреса

    alert(user?.address?.street); // undefined (без ошибки)
    ```

29. **Отличия объектов от примитивных типов данных?**

    - Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке». Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него.

    ```javascript
    let user = { name: "Иван" };

    let admin = user;

    admin.name = "Петя"; // изменено по ссылке из переменной "admin"

    alert(user.name); // 'Петя', изменения видны по ссылке из переменной "user"
    ```

    ```javascript
    let a = {};
    let b = a; // копирование по ссылке

    alert(a == b); // true, т.к. обе переменные ссылаются на один и тот же объект
    alert(a === b); // true
    ```

    ```javascript
    let a = {};
    let b = {}; // два независимых объекта

    alert(a == b); // false
    ```

30. **Какие методы есть у Объектов**

    - _Object.assign(dest, [src1, src2, src3...])_ - копирует свойства всех исходных объектов в целевой объект. Важно! этот метод не делает глубокое клонирование объекта.

      ```javascript
      let user = { name: "Иван" };

      let permissions1 = { canView: true };
      let permissions2 = { canEdit: true };

      // копируем все свойства из permissions1 и permissions2 в user
      Object.assign(user, permissions1, permissions2);

      // теперь user = { name: "Иван", canView: true, canEdit: true }
      ```

    - _Object.keys(obj)_ - Возвращает массив, содержащий имена всех собственных перечислимых свойств переданного объекта.
    - _Object.create(proto[, propertiesObject])_ - создаёт и возвращает новый объект с указанным прототипом и свойствами.

      ```javascript
      const obj = {
        sega: 19,
        adi: 18,
      };
      const newObj = Object.create(obj);
      console.log(newObj);
      ```

    - _Object.freeze()_ - замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту, удаление старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и записываемости. В сущности, объект становится эффективно неизменным. Метод возвращает замороженный объект.

    - _Object.is(value1, value2)_ - определяет, являются ли два значения одинаковыми значениями.

      ```javascript
      Object.is("foo", "foo"); // true
      Object.is(window, window); // true

      Object.is("foo", "bar"); // false
      Object.is([], []); // false

      var test = { a: 1 };
      Object.is(test, test); // true

      Object.is(null, null); // true

      // Специальные случаи
      Object.is(0, -0); // false
      Object.is(-0, -0); // true
      Object.is(NaN, 0 / 0); // true
      ```

    - _Object.defineProperty(obj, prop, descriptor)_ - определяет новое или изменяет существующее свойство непосредственно на объекте, возвращая этот объект.

    - _Object.getOwnPropertyDescriptor()_

    - _Object.getOwnPropertyNames()_

    - _Object.getOwnPropertySymbols()_

    - _Object.getPrototypeOf()_

    - _Object.isExtensible()_

    - _Object.isFrozen()_ - определяет, был ли объект заморожен.

    - _Object.isSealed()_

    - _Object.observe()_ - используется для асинхронного обзора изменений в объекте. Он предоставляет поток изменений в порядке их возникновения.

    - _Object.preventExtensions()_

    - _Object.seal()_ - запечатывает объект, предотвращая добавление новых свойств к объекту и делая все существующие свойства не настраиваемыми. Значения представленных свойств всё ещё могут изменяться, поскольку они остаются записываемыми.

    - _Object.setPrototypeOf()_

31. **Что такое ООП?**

    - Объектно ориентированное программирование - это парадигма разработки программных систем, в которой приложения состоят из объектов.

32. **4 Парадигмы ООП, и что они значат**

    - Инкапсуляция - защищает данные и код от внешнего вмешательства. Благодаря этому отсуствует риск, когда одна функция может взаимодействовать на другую без нашего ведома.
    - Наследование - с помощью наследования один объект может приобретать свойства другого
    - Полиморфизм - Возможность дополнять объект функционалом. Возможность выступать объекту в разных формах. Классический полиморфизм — замещение, переопределение методов.
    - Абстракция — в ООП это придание объекту характеристик, которые четко выделяет его на фоне остальных, определяя его концептуальные границы.

33. **Что делает цикл for in, и чем он опасен?**

    - цикл for in пробегает по ключам и свойствам объекта и выполняет функцию описанную в теле цикла. Если в объекте нет свойств, то цикл игнорируется.
    - цикл for in опасен тем, что он пробегает не только по ключам и свойствам, но и заходит в его прототип, это может привести к проблемамч

34. **что происходит со старым значением в переменной, после того как мы ее переопределили?**

    - при переопределении переменной, старое значение удаляется

35. **как называются языки программирования, в которых мы можем не связывать типы данных с переменной?**

    - язык программирование в котором мы можем не связывать тип данных с переменной называется _динамически типизированным_

36. **Как будет вести себя результат вычисления, если где-то в выражении будет NaN?**

    - если где-то в расчете будет NaN, то результатом вычислений с его участием будет NaN.

37. **Как работает оператор запятая?**

    - оператор запятая (,) - предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. Каждое выражение выполняется, но возвращается результат только последнего. оператор запятая имеет низкий приоритет, следовательно нужно использовать скобки

38. **чему равно сравнение null == undefined? что можете рассказать об этом сравнении?**

    - для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому null == 0 ложно.

39. **Как сравниваются строки?**

    - Строки сравниваются посимвольно в лексикографическом порядке

40. **Какие логические операторы есть в js? как они работают?**

    - в js, есть 3 логических оператора - || (или), && (и), ! (не)
    - оператор || - запинается на правде (result = a || b;), если все операторы ложные, то возвращается последний из них
    - оператор && - запинается на лжи ()

41. **что такое "use strict"**

    - use strict - это строгий режим в js

42. **Что вы можете рассказать про оператор "??"**

    - Оператор "??" был добавлен совсем недавно - из двух аргументов он возвращает, тот у которого значение определено (null/undefined он отсеивает). У него низкий приоритет,
      поэтому для его использования скорее всего потребуются скобки. Также этот оператор нельзя использовать с операторами _||, &&_, но можно обойти это ограничение с помощью
      скобок.

43. **как называется повторение шага в цикле?**

    - итерация

44. **Как можно завершить цикл, или перейти к следующей итерации цикла?**

    - для завершения цикла используется break, для того, чтобы перейти к следующей итерации используется continue

    ```js
    for (let i = 0; i < 10; i++) {
      // если true, пропустить оставшуюся часть тела цикла
      if (i % 2 == 0) continue;

      alert(i); // 1, затем 3, 5, 7, 9
    }
    ```

    - нельзя использовать break/continue справа от оператора "?"

45. **Как можно выйти из нескольких уровней цикла?**

    - Для выхода из нескольких уровней цикла используются _метки_ - метка имеет вид идентификатора с двоеточием перед циклом.

    ```js
    outer: for (let i = 0; i < 3; i++) {

    for (let j = 0; j < 3; j++) {

        let input = prompt(Значение на координатах (${i},${j}), '');

        // если пустая строка или Отмена, то выйти из обоих циклов
        if (!input) break outer; // (*)

        // сделать что-нибудь со значениями...
    }
    }
    alert('Готово!');
    ```

    - Вызов break/continue возможен только внутри цикла, и метка должна находиться где-то выше этой директивы.
    - Обе этих директивы поддерживают метки, которые ставятся перед циклом. Метки – единственный способ для break/continue выйти за пределы текущего цикла, повлиять на выполнение внешнего.

46. **Что вы можете рассказать о конструкции switch case?**

    - Конструкция switch заменяет собой сразу несколько if.

    ```js
    switch(x) {
      case 'value1':  // if (x === 'value1')
        ...
        [break]

      case 'value2':  // if (x === 'value2')
        ...
        [break]

      default:
        ...
        [break]
    }
    ```

    - Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее. Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch). Если ни один case не совпал – выполняется (если есть) вариант default
    - Несколько вариантов case, использующих один код, можно группировать.

    ```js
    switch (a) {
      case 4:
        alert("Правильно!");
        break;

      case 3: // (*) группируем оба case
      case 5:
        alert("Неправильно!");
        alert("Может вам посетить урок математики?");
        break;
      default:
        alert("Результат выглядит странновато. Честно.");
    }
    ```

47. **Что происходит с внешней переменной, если в функции мы объявляем переменную с таким же именем**

    - Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю.

48. **Что такое параметр по умолчанию, как его задать?**

    - параметр по умолчанию - это значение параметра, используемое функцией, если значения параметра не было передано. Мы можем присвоить параметр по умолчания, когда объявляем параметры.

      ```js
      function(a, b = 0) {}
      ```

    - В данном случае _b = 0_ это число, но на его месте могло бы быть и более сложное выражение, которое бы вычислялось и присваивалось при отсутствии параметра. Например:

      ```js
      function showMessage(from, text = anotherFunction()) {
        // anotherFunction() выполнится только если не передан text
        // результатом будет значение text
      }
      ```

49. **Если параметр не указан, то его значение?**

    - undefined

50. **Что произойдет если использовать return без значения?**

    - Пустой return аналогичен return undefined. _Он приведет к немедленному выходу из функции!_

51. **Почему не следует добавлять перенос строки между return и его значением?**

    - потому что код не выполнится, _js подставит точку с запятой после return._ Но можно осуществить перенос с помощью скобки после _return_

52. **Какие префиксы вы используете?**

    - get..., check..., count... show...

53. **функция это значение?**

    - да, функция это значение, и мы можем работать с ней как со значением - копировать функцию в другую переменную и т.д

54. **Что такое callback функция?**

    - коллбэк функция(функция обратного вызова) - функция, которая передается как аргумент другой функции.

    ```js
    function ask(question, yes, no) {
      if (confirm(question)) yes();
      else no();
    }

    ask(
      "Вы согласны?",
      function () {
        alert("Вы согласились.");
      },
      function () {
        alert("Вы отменили выполнение.");
      }
    );
    ```

55. **Что такое стрелочные функции, в чем их отличия?**

    - у _стрелочных функций_ нет this. Если происходит обращение к this, его значение берётся снаружи. 2. _конструкторы_. Например, мы можем использовать это для итерации внутри метода объекта:

    ```js
    let group = {
      title: "Our Group",
      students: ["John", "Pete", "Alice"],

      showList() {
        this.students.forEach((student) => alert(this.title + ": " + student));
      },
    };

    group.showList();
    /*Если бы мы использовали «обычную» функцию, была бы ошибка: */
    ```

    - Отсутствие this естественным образом ведёт к другому ограничению: стрелочные функции не могут быть использованы как конструкторы. Они не могут быть вызваны с new.

    - У стрелочных функций также нет переменной arguments.

    - Function Declaration может легко создавать конструкторы объектов, в то время как _стрелочная функция не может создавать конструкторы_

    - Function Declaration использует оператор возврата, в противном случае он вернет undefined. _В стрелочной функции можно вернуть значение, если в функции содержится только 1 выражение и фигурные скобки отсуствуют_

56. **Что такое BDD - Behavior Driven Development?**

    - это методология тестирования и разработки ПО.
    - Как Тесты – они гарантируют, что функция работает правильно.
    - Как Документацию – заголовки блоков describe и it описывают поведение функции.
    - Как Примеры – тесты, по сути, являются готовыми примерами использования функции.
    - В BDD сначала пишут спецификацию, а потом реализацию. В конце у нас есть и то, и другое.

    - Спецификацию можно использовать тремя способами:

    ```js
    describe("Возводит x в степень n", function () {
      it("5 в степени 1 будет 5", function () {
        assert.equal(pow(5, 1), 5);
      });

      it("5 в степени 2 будет 25", function () {
        assert.equal(pow(5, 2), 25);
      });

      it("5 в степени 3 будет 125", function () {
        assert.equal(pow(5, 3), 125);
      });
    });
    ```

57. **Что такое транспилер и полифил?**

    - Частенько приходится поддерживать браузер, который не поддерживает всех функций js для этого есть инструмент, который преобразует ваш новый код в более старые эквиваленты кода. Этот процесс обычно называют “transpiling”
    - Слово polyfill - обозначает принятие определения новой функции и создания части кода , эквивалентного поведению, но способного работать в older JS environments(старой среде js).

58. **Какие методы вы используете для чистоты кода?**

    - Использование простых, но понятных имен для переменных или функций.
    - не использовать абстрактные названия - data, value...
    - использовать одинаковое форматирование кода (prettier)
    - не создавать функции, которые реализуют несколько действий
    - стараться писать код таким образом, чтобы он не требовал комментариев - код сам должен быть комментарием

59. **Что такое линты?**

    - ESLint - это инструмент статического анализа кода для выявления проблемных шаблонов, обнаруженных в коде JavaScript. Он приводит код к более-менее единому стилю, помогает избежать глупых ошибок, умеет автоматически исправлять многие из найденных проблем и отлично интегрируется со многими инструментами разработки

60. **Принципы SOLID**

    - S single responsebility (принцип единой ответственности)
    - O open-closed (принцип открытости-закрытости)
    - L liskov substition (принцип подсановки Барбары Лисков)
    - I interface segregation (принцип разделение интерфейса)
    - D dependency inversion (принцип инверсии зависимостей)

61. **что такое кроссбраузерность**

    - Кроссбраузерность - это когда сайт отображается во всех частоиспользуемых браузерах одинаково.

62. **что такое валидность**

    - Валидность - это когда написанный код верстки, соотвествует стандартам веба W3C

63. **Что такое HTTP**

    - HyperText Transfer Protocol (HTTP) - протокол передачи данных, благодаря которым пользователь получает доступ к веб-ресурсам

64. **Что такое Json**

    - Javascript Object Notation(json) - Формат обмена и хранения данных, основанной на javascript. В Бэм используется свои правила написания имен классов
    - 1.  название блока должно содержать смысл блока, а не его описание
    - 2. Блок не должен влиять на окружение

65. **Что такое Бэм?**

    - блок элемент модификатор(Бэм) - это компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на отдельные блоки.

66. **Что такое Ajax**

    - Asynchronous Javascript and XML(Ajax) - это набор методов для веб-разработки, которые позволяют веб-приложением работать асинхронно - обрабатывать любые запросы в фоновом режиме

67. **Что такое a11y**
    a11y(Accessibility Testing) - доступность, для людей с ограниченным возможностями к информации.

68. **Что такое symbol?**

    - symbol - примитивный тип данных, который представляет собой уникальный идентификатор
    - Создаются новые символы с помощью функции Symbol():
    - Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.

    ```js
    let user = {
      name: "Вася",
    };

    let id = Symbol("id");

    user[id] = 1;

    alert(user[id]); // мы можем получить доступ к данным по ключу-символу
    ```

69. **Можем ли мы сделать symbol с двумя одинаковыми именами единой сущностью?**

    - да, с помощью _Symbol.for(key)._

    ```js
    let id = Symbol.for("id");
    let idAgain = Symbol.for("id");
    alert(id === idAgain); // true
    ```

    - Внутри метода Symbol.keyFor используется глобальный реестр символов для нахождения имени символа. Так что этот метод не будет работать для неглобальных символов. Если символ неглобальный, метод не сможет его найти и вернёт undefined.

70. **как преобразуется объект?**

    - объект преобразуется сначала в примитивы, а затем выполняется операция.

71. **можем ли мы повлиять на преобразование объекта**

    - _Мы можем повлиять на то, как объект будет преобразовываться_ при помощи методов.
    - Существует всего 3 типа преобразований (хинтов):
    - "string" (для alert и других операций, которым нужна строка)
    - "number" (для математических операций)
    - "default" (для некоторых операций)

72. **Что такое THIS**

73. **Зачем нужны функции call и apply?**

74. **Что такое линтеры?**

75. **что такое строгий режим? (strict mode)**

76. **Что такое делегирование событий?**

77. **Как работает делегирование событий?**

78. **Как работает прототипное наследование**

79. **В чем отличие forEach от map?**

80. **В чем разница между переменной , которая является: null, undefined или является необъявленной?**

81. **Каков типичный вариант использования анонимных функций?**

82. **В чем разница между объектами хоста и собственными объектами?**

83. **Объясните разницу между: function Person(){}, var person = Person()и var person = new Person()?**

84. **В чем разница между ==и ===?**

85. **Что такое тернарный оператор, почему он так называется**

86. **Какие инструменты и методы вы используете для отладки кода JavaScript?**

87. **Объясните разницу между синхронными и асинхронными функциями.**

88. **что такое функции высшего порядка?**

89. **что такое деструктаризация?**

90. **что такое promise?**

    - Promise это объект, который был создан, чтобы упростить работу с асинхронными операциями в js.

      ```js
      let promise = new Promise(function (resolve, reject) {
        // функция-исполнитель (executor)
        // "певец"
      });
      ```

    - Функция, переданная в конструкцию new Promise, называется _исполнитель_ (executor). (что-то, что обычно требует времени),
    - аргументы resolve и reject – это колбэки
    - resolve(value) — если работа завершилась успешно, с результатом value.
    - reject(error) — если произошла ошибка, error – объект ошибки.

91. **Как называются внутренние свойства Promise?**

    - state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
    - result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error)

92. **Расскажите о методах Promise**

    - У Promise есть свои методы:
    - then - Наиболее важный и фундаментальный метод – .then. _Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно»_, и получает результат. _Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой»_, и получает ошибку.

      ```js
      promise.then(
        function (result) {
          /_ обработает успешное выполнение _/;
        },
        function (error) {
          /_ обработает ошибку _/;
        }
      );
      ```

    - catch - Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента, Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает тоже самое:

      ```js
      let promise = new Promise((resolve, reject) => {
        setTimeout(() => reject(new Error("Ошибка!")), 1000);
      });
      // .catch(f) это тоже самое, что promise.then(null, f)
      promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
      ```

    - finnaly - Вызов .finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой. Обработчик, вызываемый из finally, не имеет аргументов. Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.

      ```js
      new Promise((resolve, reject) => {
        setTimeout(() => resolve("result"), 2000);
      })
        .finally(() => alert("Промис завершён"))
        .then((result) => alert(result)); // <-- .then обработает результат
      ```

93. **Что вы можете рассказать про асинхронность?**

    - js - это асинхронный, однопоточный язык программирования. Мы часто сталкиваемся с асинхронностью, когда пользуемся сайтами - например eventLoop, setTimeout...
    - Js не ждет, пока функция начнет свое выполнение, вместо этого он кладет ее в стек и вызовет, когда придет ее время(setTimeout, eventLoop..)
